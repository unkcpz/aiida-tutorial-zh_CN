# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA Tutorials package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA Tutorials\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-15 18:01+0000\n"
"PO-Revision-Date: 2019-07-15 18:03+0000\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:2
msgid "Screening"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:4
msgid ""
"In order to compute the deliverable capacity of a material, you need to "
"compute the methane loading both at the loading and at the discharge "
"pressure, and then do some simple math - in other words, a simple "
"*workflow*. AiiDA provides `WorkChains <https://aiida-"
"core.readthedocs.io/en/stable/work/index.html#workchains>`__ to orchestrate "
"the running of calculations."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:11
msgid ""
"We've prepared a WorkChain to compute the deliverable methane capacity."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:13
msgid ""
"Download it :download:`from here <../assets/deliverable_capacity.py>` and "
"place the file in some directory, then add the path to this directory to "
"``PYTHONPATH`` and restart the daemon:"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:22
msgid ""
"Now, we analyze step by step the WorkChain, and we will see later how to run"
" it."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:26
msgid "Step 0: Defining inputs, outputs and execution steps"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:28
msgid ""
"AiiDA WorkChains are python *classes*. The ``define`` method specifies the "
"inputs, the steps of execution and the outputs of the WorkChain:"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:74
msgid ""
"The ``DcMethane`` uses ``spec.input()`` to specify the following inputs: 1. "
"The structure in ``CifData`` format 1. Raspa parameters of type "
"``ParameterData`` 1. Zeo++ parameters of type ``NetworkParameters`` 1. A "
"file containing specification of atomic radii (of type ``SingleFile``) 1. "
"Zeo++ and Raspa codes (of type ``Code``)."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:80
msgid ""
"It then uses ``spec.outline()`` to specify the steps of the workchain (using"
" functions defined below). All **7 steps** will be executed in order."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:85
msgid "Step 1: Prepare input parameters and variables"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:114
msgid "Step 2: Compute the geometric parameters of the MOFs."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:116
msgid "As described in `Setting for Raspa <../theoretical/settings-raspa>`__:"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:119
msgid ""
"``BlockPockets`` and ``BlockPocketsFileName`` will be filled by AiiDA: if "
"Zeo++ finds some non accessible pore volume, it can generate a .block file "
"with the positions and the radii of blocking spheres. These spheres are "
"inserted in the framework to prevent Raspa from inserting molecules in the "
"non accessible pore."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:125
msgid ""
"Here we will compute blocked pockets of a particular material employing the "
"Zeo++ code."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:150
msgid ""
"As you can see: in order to run the calculation one just needs to provide "
"code, structure, parameters and atomic\\_radii file that are all directly "
"taken from the workflow inputs. The job submission happens in exactly the "
"same way as it was for the `single raspa calculation <methane-loading"
"#submitting-the-calculation>`__ that we tried previously."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:158
msgid ""
"The ``self.report()`` functions provides a convenient way to report the "
"status of a workflow that can be access from the verdi command line via "
"``verdi work report <PK>``"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:163
msgid "Step 3, 5: Compute the methane loading"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:165
msgid ""
"Steps 3 (``run_loading_raspa_low_p``) and 5 (``run_loading_raspa_high_p``) "
"compute the methane loading at 5.8 and 65 bars respectively in "
"[molecules/cell] units. The functions are defined as follows:"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:182
msgid "and finally execute the same ``_run_loading_raspa`` function."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:207
msgid ""
"``ToContext()`` will create a variable ``self.ctx.raspa`` that will contain "
"the results of the calculation."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:210
msgid "``Outputs()`` function will wait for the calculation to be completed."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:213
msgid "Step 4, 6: Extract pressure and methane loading"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:215
msgid ""
"Steps 4 and 6 extract pressure and methane loading (with deviation) and puts"
" them into ``loading_average`` and ``loading_dev`` dictionaries stored in "
"the **context**."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:228
msgid "Step 7: Store the selected computed parameters as the output node"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:230
msgid ""
"This final step is to prepare the results of the ``DcMethane`` workchain "
"extracting the most relevant information and putting it in a "
"``ParameterData`` object."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:234
msgid ""
"In particular, we extract the deliverable capacities at low and high "
"pressures that are computed in previous steps. We transform data from "
"[molecule/unit cell] units to [cm:sup:`3\\_STP/cm`\\ 3] using the conversion"
" factor provided by raspa (``conversion_factor_molec_uc_to_cm3stp_cm3``). We"
" also [compute] "
"(https://en.wikipedia.org/wiki/Sum\\_of\\_normally\\_distributed\\_random\\_variables)"
" the standard deviation of the difference."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:271
msgid "Exercises"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:273
msgid ""
"Before you actually start doing the calculations please setup the zeo++ code"
" as shown here::"
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:291
msgid ""
"Should you have any doubts, just consult the `Computer setup and "
"configuration <calculations#computer-setup-and-configuration>`__ part of our"
" tutorial."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:293
msgid ""
"The following script is necessary to run the ``DcMethane`` workchain. You "
"need to save it as ``run_DcMethane.py``, edit it with your settings and run "
"it with ``verdi run run_DcMethane.py``."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:401
msgid ""
"The function ``multiply_unit_cell`` is automatically computing the number of"
" ``UnitCells`` needed, ``nx ny nz``. This function contains the math to "
"`deal also with non-orthogonal unit cells <../theoretical/multiply-uc>`__."
msgstr ""

#: ../docs/pages/2019_molsim_school_Amsterdam/screening/screening.rst:406
msgid ""
"Consult the `Querying the AiiDA database <../tutorial/queries>`__ part of "
"the tutorial in order to find out which filter you should put in "
"``q.append(CifData, filters={})`` to select the appropriate structures."
msgstr ""
