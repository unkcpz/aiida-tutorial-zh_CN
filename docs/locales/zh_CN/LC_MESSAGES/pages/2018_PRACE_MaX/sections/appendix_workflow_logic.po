# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA Tutorials package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA Tutorials\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-15 06:22+0000\n"
"PO-Revision-Date: 2019-07-15 05:13+0000\n"
"Language-Team: Chinese (China) (https://www.transifex.com/scut-ccmp/teams/98995/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:1
msgid "More workflow logic: while loops and conditional statements"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:4
msgid ""
"In the previous sections, you have been introduced to WorkChains, and the "
"reason for using them over “standard” workfunctions (i.e., functions "
"decorated with @wf)."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:6
msgid ""
"However, in the example of Sec. [sec:workchainsimple], the spec.outline was "
"quite simple, with a “static” sequence of two steps. Most often, however, "
"you need dynamic workflows, where you need to decide at runtime whether to "
"continue to compute or not (e.g. in a convergence loop, where you need to "
"stop if convergence has been achieved). To support this scenario, the "
"spec.outline can support logic: while loops and if/elif/else blocks. The "
"simplest way to explain it is to show an example:"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:27
msgid "that would roughly correspond, in a python syntax, to:"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:42
msgid ""
"The only constraint is that condition functions (in the example above isA, "
"isB and condition) must be class methods that returns True or False "
"depending on whether the condition is met or not."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:44
msgid ""
"A suggestion on how to write new workchains: Use the outline to help you in "
"designing the logic. First create the spec outline writing, almost if you "
"were explaining it in words, what you expect the workflow to do. Then, "
"define one by one the methods. For example, we have prepared a simple "
"workfunction to optimize the lattice parameter of silicon efficiently using "
"a Newton’s algorithm on the energy derivative, i.e. the pressure (p=-dE/dV)."
" You can find it the code at tutorial_scripts/pressure_convergence.py. The "
"outline looks like this:"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:58
msgid ""
"This outline already roughly explains the algorithm: after an initialization"
" (init) and putting the first step (number zero) in the ctx "
"(put_step0_in_ctx), a function to move to the next step is called "
"(move_next_step). This is iterated while a given convergence criterion is "
"not met (not_converged). Finally, some reporting is done, including "
"returning some output nodes (report)."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:60
msgid ""
"If you are interested in the details of the algorithm, you can inspect the "
"file. The main ideas are described here:"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:62
msgid ""
"initGenerate a pw.x calculation for the input structure (with volume (V)), "
"and one for a structure where the volume is (V+4\\text{\\AA}^3) (just to get"
" a closeby volume). Store the results in the context as r0 and r1"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:65
msgid ""
"put_step0_in_ctxStore in the context (V), (E(V)) and (dE/dV) for the first "
"calculation r0"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:68
msgid ""
"move_next_stepThis is the most important function. Calculate (V), (E(V)) and"
" (dE/dV) for r1. Also, estimate (d^2E/dV^2) from the finite difference of "
"the first derivative of r0 and r1 (helper functions to achieve this are "
"provided). Get the (a), (b) and (c) coefficients of a parabolic fit (E=aV^2 "
"+ bV + c) and estimated the expected minimum of the EOS function as the "
"minimum of the fit (V_0=-b/2a). Finally, replace r0 with r1 in the context "
"(i.e., get rid of the oldest point) and launch a new pw calculation at "
"volume (V_0), that will be stored in the context replacing r1. In this way, "
"at the next iteration r0 and r1 will contain the latest two simulations. "
"Finally, at each step some relevant information (coefficients (a), (b) and "
"(c), volumes, energies, energy derivatives, ...) are stored in a list called"
" steps. This whole list is stored in the context because it provides "
"quantities to be preserved between different workfunction steps."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:71
msgid ""
"not_convergedReturn True if convergence has not been achieved yet. "
"Convergence is achieved if the difference in volume between the two latest "
"simulations is smaller than a given threshold (volume_tolerance)."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:74
msgid ""
"reportThis is the final step. Mainly, we return the output nodes: steps with"
" the list of results at each step, and structure with the final converged "
"structure."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:77
msgid ""
"The results returned in steps can be used to represent the evolution of the "
"minimisation algorithm. A possible way to visualize it is presented in Fig. "
"[fig:convpressure], obtained with an initial lattice constant of "
"(a_{\\text{lat}} = 5.2\\text{\\AA})."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:79
msgid ""
"![[fig:convpressure]Example of results of the convergence algorithm "
"presented in Sec. [sec:convpressure]. The bottom plot is a zoom near the "
"minimum. The dots represent the (volume,energy) points obtained from Quantum"
" ESPRESSO, and the numbers indicate at which iteration they were obtained. "
"The parabolas represent the parabolic fits used in the algorithm; the "
"minimum of the parabola is represented with a small cross, in correspondence"
" of the vertical lines, used as the volume for the following step.]({{ "
"site.baseurl}}/assets/2018_PRACE_MaX/convergence_pressure)"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:81
msgid ""
"<span>9</span> P. Giannozzi et al., J.Phys. Cond. Matt. 29, 465901 (2017). "
"S. R. Bahn and K. W. Jacobsen, Comput. Sci. Eng., 4, 56-66 (2002). S. Ping "
"Ong et al., Comput. Mater. Sci. 68, 314-319 (2013). K.F. Garrity, J.W. "
"Bennett, K.M. Rabe and D. Vanderbilt, Comput. Mater. Sci. 81, 446 (2014). G."
" Prandini, A. Marrazzo, I. E. Castelli, N. Mounet, N. Marzari, A Standard "
"Solid State Pseudopotentials (SSSP) library optimized for accuracy and "
"efficiency (Version 1.0, data download), Materials Cloud Archive (2018), "
"doi:10.24435/materialscloud:2018.0001/v1. Crystallographic Open Database "
"(<span>COD</span>), http://www.crystallography.net/cod/."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:83
msgid ""
"[1] The string provided to the DataFactory encodes both the location and the"
" name of the required class according to some specific rules."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:85
msgid ""
"[2] if you set the structure incorrectly, for example with overlapping "
"atoms, it is very likely that any DFT code will fail!"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:87
msgid ""
"[3] We purposefully do not provide advanced commands for crystal structure "
"manipulation in AiiDA, because python packages that accomplish such tasks "
"already exist (such as ASE or pymatgen)."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:89
msgid "[4] https://aiidateam.github.io/aiida-registry/"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:91
msgid ""
"[5] http://www.quantum-espresso.org/wp-content/uploads/Doc/INPUT_PW.html"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:93
msgid ""
"[6] http://aiida-"
"core.readthedocs.io/en/latest/plugins/quantumespresso/pw.html"
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:95
msgid ""
"[7] However, to avoid duplication of KpointsData, you should first learn how"
" to query the database, therefore we will ignore this duplication issue for "
"now."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:97
msgid ""
"[8] For JobCalculations (i.e., calculations that are submitted to a remote "
"computer through a scheduler) there is an additional “Job state” (last "
"column of the output of verdi calculation list) that can either be FINISHED "
"if all went well, or one of the possible failure states (FAILED, "
"PARSINGFAILED, SUBMISSIONFAILED, RETRIEVALFAILED). These states are "
"represented as a Finished state (third column of verdi calculation list, "
"with a zero/non-zero error code depending if they finished/did not finish "
"correctly). This latter state is more general than just JobCalculations and "
"also applies to workflows, as we will see later in the tutorial."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:99
msgid ""
"[9] In simple (or even simplified) words, a decorator is a function that "
"modifies the behavior of another function. In python, a function can be "
"decorated by adding a line of the form @decorating_function_name on the line"
" just before the def line of the decorated function. If you want to know "
"more, there are many online resources explaining python decorators."
msgstr ""

#: ../docs/pages/2018_PRACE_MaX/sections/appendix_workflow_logic.md:101
msgid ""
"[10] If you are curious: the two links have the same label, but are of "
"different link_type: one is a create link, that keeps track of the "
"calculation that actually generated the node. Instead the other one is of "
"type return, stating that the workfunction, beside creating that node, also "
"returned it as an output. Calculation 5002 instead only returned the node "
"but it did not generate it, therefore there is only one link between it and "
"the final StructureData."
msgstr ""
